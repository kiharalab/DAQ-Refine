import os
import os.path
import re
import hashlib
import random
import string
import urllib.request
import subprocess


from sys import version_info
python_version = f"{version_info.major}.{version_info.minor}"

# STEP-1: Input Protein Sequence and DAQ result file

# 1. Select the DAQ-refine strategy:
# * **Vanilla AlphaFold2** : does not use the DAQ-score result.
# * **Strategy-1**: DAQ-score + ColabFold with a trimmed template model.
# * **Strategy-2**: DAQ-score + ColabFold with a trimmed template model + trimmed MSAs.

# 2. **If you select Strategy-1 or -2**, upload a result file (**daq_score_w9.pdb**) generated by [DAQ-score colab](https://colab.research.google.com/drive/1Q-Dj42QjVO8TCOLXMQBJlvm1zInxPkOu?usp=sharing).

# 3. **If you select Strategy-2**, upload MSA file in **Input data** cell.



def TrimDAQ(filename,cutoff,outfile):
    daq=[]
    PDB={}
    lines=''
    with open(filename) as f:
        for li in f:
            #print(li)
            if li.startswith('ATOM'):
                li=li.strip()
                resn = int(li[23:27])
                sco = float(li[60:66])
                x = float(li[30:38])
                y = float(li[38:46])
                z = float(li[46:54])
                PDB[str(resn)]=[x,y,z,sco]
                if sco < cutoff:
                    #print(sco)
                    daq.append(resn)
                else:
                    lines=lines+li+'\n'
    #print(lines)
    with open(outfile,'w') as out:
        out.write(lines)

# rand_letters = string.ascii_lowercase
# rand_letters = ''.join(random.choice(rand_letters) for i in range(20))
# daq_file=''
# str_mode = "strategy2" #@param ["Vanilla AF2","strategy1","strategy2"]


# if str_mode == "strategy1" or str_mode == "strategy2":
  # root_dir = os.getcwd()
  # upload_dir = os.path.join(root_dir,rand_letters)
  # if not os.path.exists(upload_dir):
  #   os.mkdir(upload_dir)
  # os.chdir(upload_dir)
  # print("Please Upload daq_score_w9.pdb (DAQ-score output file) HERE")
  # pdb_input = files.upload()

  # for fn in pdb_input.keys():
  #   print('User uploaded file "{name}" with length {length} bytes'.format(
  #     name=fn, length=len(pdb_input[fn])))
  #   pdb_input_path = os.path.abspath(fn)
  #   print("PDB save to %s"%pdb_input_path)
  #   TrimDAQ(pdb_input_path,0.0,upload_dir+'/1tmp.pdb')  
  #   #files.download(upload_dir+'/1tmp.pdb')
  #   #convert PDB to CIF
  #   !$maxit -input 1tmp.pdb -output 1tmp.cif -o 1
  #   #files.download(upload_dir+'/1tmp.cif')
  #   daq_file=upload_dir+'/1tmp.cif'
  # os.chdir(root_dir)
daq_file = ''
daq_msa = ''
def add_hash(x, y):
    return x + "_" + hashlib.sha1(y.encode()).hexdigest()[:5]

def get_input(args):
    global daq_file
    if args.str_mode in ("strategy 1", "strategy 2"):
        try:
            TrimDAQ(args.pdb_input_path, 0.0, args.input_path+'/1tmp.pdb')
        except Exception as e:
            print(f"Error while trimming DAQ: {e}")
            return False

        try:
            subprocess.run(["maxit", "-input", "1tmp.pdb", "-output", "1tmp.cif", "-o", "1"], check=True)
            daq_file = args.input_path+'/1tmp.cif'
        except subprocess.CalledProcessError as e:
            print(f"Maxit subprocess failed: {e}")
            return False

        return True
    return False


#@title Prepare a trimmed template model

##Use Colab Fold Part
# from google.colab import files
# import os.path
# import re
# import hashlib
# import random

# def add_hash(x,y):
#   return x+"_"+hashlib.sha1(y.encode()).hexdigest()[:5]

def prepare_trimmed_template(args):
    global daq_file, daq_msa
    # Input target sequence
    query_sequence = 'MGEVTAEEVEKFLDSNVSFAKQYYNLRYRAKVISDLLGPREAAVDFSNYHALNSVEESEIIFDLLRDFQDNLQAEKCVFNVMKKLCFLLQADRMSLFMYRARNGIAELATRLFNVHKDAVLEECLVAPDSEIVFPLDMGVVGHVALSKKIVNVPNTEEDEHFCDFVDTLTEYQTKNILASPIMNGKDVVAIIMVVNKVDGPHFTENDEEILLKYLNFANLIMKVFHLSYLHNCETRRGQILLWSGSKVFEELTDIERQFHKALYTVRAFLNCDRYSVGLLDMTKQKEFFDVWPVLMGEAPPYAGPRTPDGREINFYKVIDYILHGKEDIKVIPNPPPDHWALVSGLPTYVAQNGLICNIMNAPSEDFFAFQKEPLDESGWMIKNVLSMPIVNKKEEIVGVATFYNRKDGKPFDEMDETLMESLTQFLGWSVLNPDTYELMNKLENRKDIFQDMVKYHVKCDNEEIQTILKTREVYGKEPWECEEEELAEILQGELPDADKYEINKFHFSDLPLTELELVKCGIQMYYELKVVDKFHIPQEALVRFMYSLSKGYRRITYHNWRHGFNVGQTMFSLLVTGKLKRYFTDLEALAMVTAAFCHDIDHRGTNNLYQMKSQNPLAKLHGSSILERHHLEFGKTLLRDESLNIFQNLNRRQHEHAIHMMDIAIIATDLALYFKKRTMFQKIVDQSKTYETQQEWTQYMMLDQTRKEIVMAMMMTACDLSAITKPWEVQSKVALLVAAEFWEQGDLERTVLQQNPIPMMDRNKADELPKLQVGFIDFVCTFVYKEFSRFHEEITPMLDGITNNRKEWKALADEYETKMKGLEEEKQKQQAANQAAAGSQHGGKQPGGGPASKSCCVQ'
    # Remove whitespaces
    query_sequence = "".join(query_sequence.split())

    # Job name
    str_mode = args.str_mode
    jobname = args.jobname
    template_mode = args.template_mode
    # Remove whitespaces and special characters
    basejobname = "".join(jobname.split())
    basejobname = re.sub(r'\W+', '', basejobname)
    jobname = add_hash(basejobname, query_sequence)

    while os.path.isfile(f"{jobname}.csv"):
        jobname = add_hash(basejobname, ''.join(random.sample(query_sequence, len(query_sequence))))

    with open(f"{jobname}.csv", "w") as text_file:
        text_file.write(f"id,sequence\n{jobname},{query_sequence}")

    queries_path = f"{jobname}.csv"

    # Number of models to use
    num_relax = int(args.num_relax)
    use_amber = num_relax > 0

    # Template mode
    # template_mode = args.template_mode
    #This option is only active for Vanilla AF mode.
    #"none" = no template information is used, "pdb70" = detect templates in pdb70, "custom" - upload and search own templates (PDB or mmCIF format, see [notes below](#custom_templates))
    #TODO: add functions for Vanilla AF
    custom_template_path = f"{jobname}_template"

    if str_mode == "strategy 1" or str_mode == "strategy 2":
        if not os.path.exists(custom_template_path):
            os.mkdir(custom_template_path)
            
            use_templates = True
            
            # Assume daq_file is provided as a local path by the user
            # daq_file = input("Please enter the local path of your daq_file: ")
            try:
                os.rename(daq_file, f"{jobname}_template/1tmp.cif")
            except FileNotFoundError:
                print("Could not find daq_file to rename.")
                return False

            return True
            
            template_mode = "custom"

        elif template_mode == "pdb70":
            use_templates = True
            custom_template_path = None

        elif template_mode == "custom":
            if not os.path.exists(custom_template_path):
                os.mkdir(custom_template_path)
            
            # uploaded_file_path = input("Please enter the local path of the file you wish to upload: ")
            
            use_templates = True
            filename = os.path.basename(uploaded_file_path)
            os.rename(uploaded_file_path, f"{jobname}_template/{filename}")

        else:
            custom_template_path = None
            use_templates = False

#@markdown Input target sequence
# query_sequence = 'MGEVTAEEVEKFLDSNVSFAKQYYNLRYRAKVISDLLGPREAAVDFSNYHALNSVEESEIIFDLLRDFQDNLQAEKCVFNVMKKLCFLLQADRMSLFMYRARNGIAELATRLFNVHKDAVLEECLVAPDSEIVFPLDMGVVGHVALSKKIVNVPNTEEDEHFCDFVDTLTEYQTKNILASPIMNGKDVVAIIMVVNKVDGPHFTENDEEILLKYLNFANLIMKVFHLSYLHNCETRRGQILLWSGSKVFEELTDIERQFHKALYTVRAFLNCDRYSVGLLDMTKQKEFFDVWPVLMGEAPPYAGPRTPDGREINFYKVIDYILHGKEDIKVIPNPPPDHWALVSGLPTYVAQNGLICNIMNAPSEDFFAFQKEPLDESGWMIKNVLSMPIVNKKEEIVGVATFYNRKDGKPFDEMDETLMESLTQFLGWSVLNPDTYELMNKLENRKDIFQDMVKYHVKCDNEEIQTILKTREVYGKEPWECEEEELAEILQGELPDADKYEINKFHFSDLPLTELELVKCGIQMYYELKVVDKFHIPQEALVRFMYSLSKGYRRITYHNWRHGFNVGQTMFSLLVTGKLKRYFTDLEALAMVTAAFCHDIDHRGTNNLYQMKSQNPLAKLHGSSILERHHLEFGKTLLRDESLNIFQNLNRRQHEHAIHMMDIAIIATDLALYFKKRTMFQKIVDQSKTYETQQEWTQYMMLDQTRKEIVMAMMMTACDLSAITKPWEVQSKVALLVAAEFWEQGDLERTVLQQNPIPMMDRNKADELPKLQVGFIDFVCTFVYKEFSRFHEEITPMLDGITNNRKEWKALADEYETKMKGLEEEKQKQQAANQAAAGSQHGGKQPGGGPASKSCCVQ' #@param {type:"string"}

# remove whitespaces
# query_sequence = "".join(query_sequence.split())

# jobname = '7jsn1_sg2' #@param {type:"string"}
# remove whitespaces
# basejobname = "".join(jobname.split())
# basejobname = re.sub(r'\W+', '', basejobname)
# jobname = add_hash(basejobname, query_sequence)
# while os.path.isfile(f"{jobname}.csv"):
#   jobname = add_hash(basejobname, ''.join(random.sample(query_sequence,len(query_sequence))))

# with open(f"{jobname}.csv", "w") as text_file:
#     text_file.write(f"id,sequence\n{jobname},{query_sequence}")

# queries_path=f"{jobname}.csv"

# number of models to use
# num_relax = 0 #@param [0, 1, 5] {type:"raw"}
# use_amber = num_relax > 0
#use_amber = False #@param {type:"boolean"}
# template_mode = "none" #@param ["none", "pdb70","custom"]
#@markdown - This option is only active for Vanilla AF mode.
#@markdown - "none" = no template information is used, "pdb70" = detect templates in pdb70, "custom" - upload and search own templates (PDB or mmCIF format, see [notes below](#custom_templates))


# if str_mode == "strategy1" or str_mode == "strategy2":
#   custom_template_path = f"{jobname}_template"
#   os.mkdir(custom_template_path)
#   #uploaded = files.upload()
#   use_templates = True
#   #for fn in uploaded.keys():
#   fn = daq_file
#   os.rename(fn, f"{jobname}_template/1tmp.cif")
#   template_mode = "custom"
# elif template_mode == "pdb70":
#   use_templates = True
#   custom_template_path = None
# elif template_mode == "custom":
#   custom_template_path = f"{jobname}_template"
#   os.mkdir(custom_template_path)
#   uploaded = files.upload()
#   use_templates = True
#   for fn in uploaded.keys():
#     os.rename(fn, f"{jobname}_template/{fn}")
# else:
#   custom_template_path = None
#   use_templates = False

##MSA part##
def trim_a3m(a3m,daq,good):

    out=[]
    for ith in range(len(a3m)):
        name,seq = a3m[ith]
        new_seq=''
        if ith == 0:#query
            new_seq = seq
        else:
            pos=0
            for aa in seq:
                if aa == aa.lower() and aa != '-':
                    continue
                pos = pos + 1
                if pos in daq: #selected bad regions or missing regions
                    new_seq = new_seq + aa
                elif not pos in good:
                    new_seq = new_seq + aa
                elif aa == aa.upper():
                    new_seq = new_seq + '-'
        out.append([name,new_seq])
    return out

def ReadA3M(filename):
    A3M=[]
    with open(filename) as f:
        for li in f:
            if li.startswith('#'):
                continue
            if li.startswith('>'):
                name = li.strip()
            else:
                seq = li.strip()
                A3M.append([name,seq])
    return A3M

def ReadDAQ(filename,cutoff,dist_cut):
    daq=[]
    PDB={}
    with open(filename) as f:
        for li in f:
            #print(li)
            if li.startswith('ATOM') and li[13:16]=='CA ':
                li=li.strip()
                resn = int(li[23:27])
                sco = float(li[60:66])
                x = float(li[30:38])
                y = float(li[38:46])
                z = float(li[46:54])
                PDB[str(resn)]=[x,y,z,sco]
                if sco < cutoff:
                    #print(sco)
                    daq.append(resn)
    print(daq)
    daq2=[]
    for resn in PDB:
        if int(resn) in daq:
            continue
        #Distance check
        x1=PDB[resn][0]
        y1=PDB[resn][1]
        z1=PDB[resn][2]
        for resn2 in PDB:
            if not int(resn2) in daq:
                continue
            x2=PDB[resn2][0]
            y2=PDB[resn2][1]
            z2=PDB[resn2][2]
            dist=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2)
            if dist <=dist_cut*dist_cut:#close
                daq2.append(int(resn))
                break
    #print('LowDAQ',daq,'Extended',daq2)
    daq=list(set(daq+daq2))
    #Others
    goodpos=[]
    for resn in PDB:
        if int(resn) in daq:
            continue
        goodpos.append(int(resn))
    print('HighDAQ',goodpos)

    return daq,goodpos

def save_a3m(file,a3m):
    lines=''
    for name,seq in a3m:
        lines = lines + name+'\n'
        lines = lines + seq+'\n'
    with open(file,'w') as out:
        out.write(lines)

#Use MSA


def msa(args):
    global daq_file, daq_msa
    str_mode = args.str_mode
    if args.str_mode == "strategy2":
        # print('Please upload MSA file (a3m format)')

        # Assume cust_msa_file and pdb_input_path are provided as local paths by the user
        cust_msa_file = args.cust_msa_file
        pdb_input_path = args.pdb_input_path

        if not os.path.isfile(pdb_input_path):
            print('Cannot find DAQ-score output file!!')
            exit(1)  # Or handle this case differently
        
        # print(f'User uploaded MSA file at {cust_msa_file}')
        
        try:
            a3m = ReadA3M(args.cust_msa_path)
            daq, good = ReadDAQ(args.pdb_input_path, 0.0, 0.0)
        except FileNotFoundError:
            print("MSA file or DAQ-score output file not found.")
            return False
        
        new_a3m = trim_a3m(a3m, daq, good)
        
        filename = os.path.join(args.input_path, 'trimmed_msa.a3m')
        save_a3m(filename, new_a3m)
        daq_msa = filename

# if str_mode == "strategy2":
#   root_dir = os.getcwd()
#   print(root_dir)
#   print('Please upload MSA file (a3m format)')
#   upload_dir = os.path.join(root_dir,rand_letters)
#   if not os.path.exists(upload_dir):
#     os.mkdir(upload_dir)
#   os.chdir(upload_dir)
#   cust_msa_input = files.upload()

#   if not os.path.isfile(pdb_input_path):
#     print('Can not find DAQ-score output file!!')


#   for fn in cust_msa_input.keys():
#     print('User uploaded file "{name}" with length {length} bytes'.format(
#       name=fn, length=len(cust_msa_input[fn])))
#     cust_msa_path = os.path.abspath(fn)
#     print("MSA save to %s"%cust_msa_path)
#     a3m=ReadA3M(cust_msa_path)
#     daq,good=ReadDAQ(pdb_input_path,0.0,0.0)
#     new_a3m=trim_a3m(a3m,daq,good)
#     filename=upload_dir+'/trimmed_msa.a3m'
#     save_a3m(filename,new_a3m)
#     daq_msa = filename
#     #files.download(filename)
#   os.chdir(root_dir)


import argparse

def get_arguments():
    parser = argparse.ArgumentParser(description='STEP-1: Input Protein Sequence and DAQ result file')

    # Add arguments
    parser.add_argument('--str_mode', type=str, default='strategy2',
                        help='Select the DAQ-refine strategy. Choices are Vanilla AF2, strategy 1, and strategy 2.')
    
    parser.add_argument('--query_sequence', type=str, default='',
                        help='Input target protein sequence.')

    parser.add_argument('--jobname', type=str, default='',
                        help='Job name for the task.')
    
    parser.add_argument('--num_relax', type=int, default=0,
                        help='Number of models to use.')
    
    parser.add_argument('--template_mode', type=str, default='none',
                        help='Template mode: none, pdb70, or custom.')
    
    parser.add_argument('--pdb_input_path', type=str, default='',
                        help='Path to the DAQ-score output file (if applicable).')
    
    parser.add_argument('--cust_msa_path', type=str, default='',
                        help='Path to the custom MSA file (if applicable).')

    parser.add_argument('--input_path', type=str, default='',
                        help='Path to the directory of the input files.')

    parser.add_argument('--output_path', type=str, default='',
                        help='Path to the directory of the output files.')

    args = parser.parse_args()

    return args

if __name__ == '__main__':
    args = get_arguments()
    input_success = get_input(args)
    if not input_success:
        print("Exiting due to error in input.")
        exit(1)
    template_success = prepare_trimmed_template(args)
    if not template_success:
        print("Exiting due to error in template preparation.")
        exit(1)
    msa_success = msa(args)
    if not msa_success:
        print("Exiting due to error in MSA.")
        exit(1)



    print("Selected strategy mode:", args.str_mode)
    print("Input query sequence:", args.query_sequence)
    print("Job ID:", args.jobname)
    print("Number of models to use:", args.num_relax)
    print("Template mode:", args.template_mode)
    print("Path to DAQ-score output file:", args.pdb_input_path)
    print("Path to custom MSA file:", args.cust_msa_path)
